//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.13.2
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from CryptoScript.g4 by ANTLR 4.13.2

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

using System;
using System.IO;
using System.Text;
using System.Diagnostics;
using System.Collections.Generic;
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.13.2")]
[System.CLSCompliant(false)]
public partial class CryptoScriptParser : Parser {
	protected static DFA[] decisionToDFA;
	protected static PredictionContextCache sharedContextCache = new PredictionContextCache();
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, T__7=8, INT=9, 
		T_KEY=10, T_VAR=11, T_PARAMETER=12, T_PATH=13, T_TR31H=14, PATH=15, FN=16, 
		INFO=17, ID=18, HEX_STRING=19, BASE64_STRING=20, NORMAL_STRING=21, TR31_STRING=22, 
		MECHANISM=23, M_AES_ECB=24, M_AES_CBC=25, M_AES_CTR=26, M_AES_CMAC=27, 
		M_AES_GCM=28, M_AES_CCM=29, M_AES_GMAC=30, M_DES3_ECB=31, M_DES3_CBC=32, 
		M_DES3_RETAIL=33, M_DES3_CMAC=34, M_WRAP_AES_TR31=35, M_WRAP_DES3_TR31=36, 
		M_WRAP_AES=37, M_WRAP_DES3=38, M_BIND_XOR=39, M_BIND_CMAC=40, PADDING=41, 
		PAD_ISO7816=42, PAD_PKCS7=43, PAD_ISO9797=44, PAD_ANSI_X923=45, PAD_NONE=46, 
		PARAM_TYPE=47, P_MECHANISM=48, P_IV=49, P_PADDING=50, P_NONCE=51, P_COUNTER=52, 
		P_ADATA=53, P_BLKHDR=54, P_KEYBIND=55, P_RND=56, WS=57, TR31_FIELD_NAME=58, 
		TR31_FIELD_VALUE=59, TR31_KB_VERSION_ID=60, TR31_KB_LENGTH=61, TR31_TRANSPORTED_KEYLEN=62, 
		TR31_KU=63, TR31_ALGO=64, TR31_MODEU=65, TR31_KEY_VERSION_NUM=66, TR31_EXPORTABILITY=67, 
		TR31_NUM_OPT_BLOCKS=68, TR31_KEY_CONTEXT=69, TR31_RESERVED_FIELD=70, TR31_OPT_BLOCK_ID=71, 
		TR31_OPT_BLOCK_DATA=72, NUM=73, KU_B0=74, KU_B1=75, KU_B2=76, KU_B3=77, 
		KU_C0=78, KU_D0=79, KU_D1=80, KU_D2=81, KU_D3=82, KU_E0=83, KU_E1=84, 
		KU_E2=85, KU_E3=86, KU_F3=87, KU_F4=88, KU_F5=89, KU_F6=90, KU_I0=91, 
		KU_K0=92, KU_K1=93, KU_K2=94, KU_K3=95, KU_K4=96, KU_M0=97, KU_M1=98, 
		KU_P2=99, KU_V0=100, KU_V1=101, KU_V2=102, KU_V3=103, KU_V4=104, KU_V5=105, 
		OPT_AL=106, OPT_BI=107, OPT_CT=108, OPT_DA=109, OPT_HM=110, OPT_IK=111, 
		OPT_KC=112, OPT_KP=113, OPT_KS=114, OPT_KV=115, OPT_LB=116, OPT_PA=117, 
		OPT_PB=118, OPT_PK=119, OPT_TC=120, OPT_TS=121, OPT_WP=122, H=123, R=124, 
		S=125, T=126, D=127, E=128, A=129, B=130, C=131, G=132, N=133, V=134, 
		X=135, Y=136;
	public const int
		RULE_program = 0, RULE_statement = 1, RULE_declaration = 2, RULE_declareparam = 3, 
		RULE_type = 4, RULE_tr31Header = 5, RULE_tr31Field = 6, RULE_expression = 7, 
		RULE_functionCall = 8, RULE_arguments = 9, RULE_argument = 10;
	public static readonly string[] ruleNames = {
		"program", "statement", "declaration", "declareparam", "type", "tr31Header", 
		"tr31Field", "expression", "functionCall", "arguments", "argument"
	};

	private static readonly string[] _LiteralNames = {
		null, "'='", "':'", "'{'", "'}'", "';'", "'('", "')'", "','", null, "'KEY'", 
		"'VAR'", "'PARAM'", "'PATH'", "'TR31H'", null, null, null, null, null, 
		null, null, null, null, "'AES-ECB'", "'AES-CBC'", "'AES-CTR'", "'AES-CMAC'", 
		"'AES-GCM'", "'AES-CCM'", "'AES-GMAC'", "'DES3-ECB'", "'DES3-CBC'", "'DES3-RETAIL'", 
		"'DES3-CMAC'", "'WRAP-AES-TR31'", "'WRAP-DES3-TR31'", "'WRAP-AES'", "'WRAP-DES3'", 
		"'BIND-XOR'", "'BIND-CMAC'", null, "'ISO-7816'", "'PKCS-7'", "'ISO-9797'", 
		"'ANSI-X923'", "'NONE'", null, "'#MECH'", "'#IV'", "'#PAD'", "'#NONCE'", 
		"'#COUNTER'", "'#ADATA'", "'#BLKH'", "'#BIND'", "'#RND'", null, null, 
		null, "'KBVID'", "'KBLEN'", "'TKL'", "'KEYU'", "'ALGO'", "'MODEU'", "'KEYVN'", 
		"'EXP'", "'NUMOPTB'", "'KEYCTX'", "'RSV'", "'OPTID'", "'OPTBD'", null, 
		"'B0'", "'B1'", "'B2'", "'B3'", "'C0'", "'D0'", "'D1'", "'D2'", "'D3'", 
		"'E0'", "'E1'", "'E2'", "'E3'", "'F3'", "'F4'", "'F5'", "'F6'", "'I0'", 
		"'K0'", "'K1'", "'K2'", "'K3'", "'K4'", "'M0'", "'M1'", "'P2'", "'V0'", 
		"'V1'", "'V2'", "'V3'", "'V4'", "'V5'", "'AL'", "'BI'", "'CT'", "'DA'", 
		"'HM'", "'IK'", "'KC'", "'KP'", "'KS'", "'KV'", "'LB'", "'PA'", "'PB'", 
		"'PK'", "'TC'", "'TS'", "'WP'", "'H'", "'R'", "'S'", "'T'", "'D'", "'E'", 
		"'A'", "'B'", "'C'", "'G'", "'N'", "'V'", "'X'", "'Y'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, null, "INT", "T_KEY", 
		"T_VAR", "T_PARAMETER", "T_PATH", "T_TR31H", "PATH", "FN", "INFO", "ID", 
		"HEX_STRING", "BASE64_STRING", "NORMAL_STRING", "TR31_STRING", "MECHANISM", 
		"M_AES_ECB", "M_AES_CBC", "M_AES_CTR", "M_AES_CMAC", "M_AES_GCM", "M_AES_CCM", 
		"M_AES_GMAC", "M_DES3_ECB", "M_DES3_CBC", "M_DES3_RETAIL", "M_DES3_CMAC", 
		"M_WRAP_AES_TR31", "M_WRAP_DES3_TR31", "M_WRAP_AES", "M_WRAP_DES3", "M_BIND_XOR", 
		"M_BIND_CMAC", "PADDING", "PAD_ISO7816", "PAD_PKCS7", "PAD_ISO9797", "PAD_ANSI_X923", 
		"PAD_NONE", "PARAM_TYPE", "P_MECHANISM", "P_IV", "P_PADDING", "P_NONCE", 
		"P_COUNTER", "P_ADATA", "P_BLKHDR", "P_KEYBIND", "P_RND", "WS", "TR31_FIELD_NAME", 
		"TR31_FIELD_VALUE", "TR31_KB_VERSION_ID", "TR31_KB_LENGTH", "TR31_TRANSPORTED_KEYLEN", 
		"TR31_KU", "TR31_ALGO", "TR31_MODEU", "TR31_KEY_VERSION_NUM", "TR31_EXPORTABILITY", 
		"TR31_NUM_OPT_BLOCKS", "TR31_KEY_CONTEXT", "TR31_RESERVED_FIELD", "TR31_OPT_BLOCK_ID", 
		"TR31_OPT_BLOCK_DATA", "NUM", "KU_B0", "KU_B1", "KU_B2", "KU_B3", "KU_C0", 
		"KU_D0", "KU_D1", "KU_D2", "KU_D3", "KU_E0", "KU_E1", "KU_E2", "KU_E3", 
		"KU_F3", "KU_F4", "KU_F5", "KU_F6", "KU_I0", "KU_K0", "KU_K1", "KU_K2", 
		"KU_K3", "KU_K4", "KU_M0", "KU_M1", "KU_P2", "KU_V0", "KU_V1", "KU_V2", 
		"KU_V3", "KU_V4", "KU_V5", "OPT_AL", "OPT_BI", "OPT_CT", "OPT_DA", "OPT_HM", 
		"OPT_IK", "OPT_KC", "OPT_KP", "OPT_KS", "OPT_KV", "OPT_LB", "OPT_PA", 
		"OPT_PB", "OPT_PK", "OPT_TC", "OPT_TS", "OPT_WP", "H", "R", "S", "T", 
		"D", "E", "A", "B", "C", "G", "N", "V", "X", "Y"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "CryptoScript.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override int[] SerializedAtn { get { return _serializedATN; } }

	static CryptoScriptParser() {
		decisionToDFA = new DFA[_ATN.NumberOfDecisions];
		for (int i = 0; i < _ATN.NumberOfDecisions; i++) {
			decisionToDFA[i] = new DFA(_ATN.GetDecisionState(i), i);
		}
	}

		public CryptoScriptParser(ITokenStream input) : this(input, Console.Out, Console.Error) { }

		public CryptoScriptParser(ITokenStream input, TextWriter output, TextWriter errorOutput)
		: base(input, output, errorOutput)
	{
		Interpreter = new ParserATNSimulator(this, _ATN, decisionToDFA, sharedContextCache);
	}

	public partial class ProgramContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode Eof() { return GetToken(CryptoScriptParser.Eof, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext[] statement() {
			return GetRuleContexts<StatementContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public StatementContext statement(int i) {
			return GetRuleContext<StatementContext>(i);
		}
		public ProgramContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_program; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.EnterProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.ExitProgram(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICryptoScriptVisitor<TResult> typedVisitor = visitor as ICryptoScriptVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitProgram(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ProgramContext program() {
		ProgramContext _localctx = new ProgramContext(Context, State);
		EnterRule(_localctx, 0, RULE_program);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 25;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while ((((_la) & ~0x3f) == 0 && ((1L << _la) & 97280L) != 0)) {
				{
				{
				State = 22;
				statement();
				}
				}
				State = 27;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			State = 28;
			Match(Eof);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class StatementContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public DeclarationContext declaration() {
			return GetRuleContext<DeclarationContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		public StatementContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_statement; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.EnterStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.ExitStatement(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICryptoScriptVisitor<TResult> typedVisitor = visitor as ICryptoScriptVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitStatement(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public StatementContext statement() {
		StatementContext _localctx = new StatementContext(Context, State);
		EnterRule(_localctx, 2, RULE_statement);
		try {
			State = 32;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case T_KEY:
			case T_VAR:
			case T_PARAMETER:
			case T_PATH:
			case T_TR31H:
				EnterOuterAlt(_localctx, 1);
				{
				State = 30;
				declaration();
				}
				break;
			case FN:
				EnterOuterAlt(_localctx, 2);
				{
				State = 31;
				functionCall();
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclarationContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public TypeContext type() {
			return GetRuleContext<TypeContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(CryptoScriptParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclareparamContext[] declareparam() {
			return GetRuleContexts<DeclareparamContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public DeclareparamContext declareparam(int i) {
			return GetRuleContext<DeclareparamContext>(i);
		}
		[System.Diagnostics.DebuggerNonUserCode] public Tr31HeaderContext tr31Header() {
			return GetRuleContext<Tr31HeaderContext>(0);
		}
		public DeclarationContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declaration; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.EnterDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.ExitDeclaration(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICryptoScriptVisitor<TResult> typedVisitor = visitor as ICryptoScriptVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclaration(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclarationContext declaration() {
		DeclarationContext _localctx = new DeclarationContext(Context, State);
		EnterRule(_localctx, 4, RULE_declaration);
		int _la;
		try {
			State = 58;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,3,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 34;
				type();
				State = 35;
				Match(ID);
				State = 36;
				Match(T__0);
				State = 37;
				expression();
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 39;
				type();
				State = 40;
				Match(ID);
				State = 41;
				Match(T__0);
				State = 42;
				functionCall();
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 44;
				type();
				State = 45;
				Match(ID);
				State = 46;
				Match(T__0);
				State = 50;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
				while (_la==PARAM_TYPE) {
					{
					{
					State = 47;
					declareparam();
					}
					}
					State = 52;
					ErrorHandler.Sync(this);
					_la = TokenStream.LA(1);
				}
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 53;
				type();
				State = 54;
				Match(ID);
				State = 55;
				Match(T__0);
				State = 56;
				tr31Header();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DeclareparamContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PARAM_TYPE() { return GetToken(CryptoScriptParser.PARAM_TYPE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MECHANISM() { return GetToken(CryptoScriptParser.MECHANISM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PADDING() { return GetToken(CryptoScriptParser.PADDING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HEX_STRING() { return GetToken(CryptoScriptParser.HEX_STRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(CryptoScriptParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NORMAL_STRING() { return GetToken(CryptoScriptParser.NORMAL_STRING, 0); }
		public DeclareparamContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_declareparam; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.EnterDeclareparam(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.ExitDeclareparam(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICryptoScriptVisitor<TResult> typedVisitor = visitor as ICryptoScriptVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitDeclareparam(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public DeclareparamContext declareparam() {
		DeclareparamContext _localctx = new DeclareparamContext(Context, State);
		EnterRule(_localctx, 6, RULE_declareparam);
		try {
			State = 75;
			ErrorHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(TokenStream,4,Context) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 60;
				Match(PARAM_TYPE);
				State = 61;
				Match(T__1);
				State = 62;
				Match(MECHANISM);
				}
				break;
			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 63;
				Match(PARAM_TYPE);
				State = 64;
				Match(T__1);
				State = 65;
				Match(PADDING);
				}
				break;
			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 66;
				Match(PARAM_TYPE);
				State = 67;
				Match(T__1);
				State = 68;
				Match(HEX_STRING);
				}
				break;
			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 69;
				Match(PARAM_TYPE);
				State = 70;
				Match(T__1);
				State = 71;
				Match(ID);
				}
				break;
			case 5:
				EnterOuterAlt(_localctx, 5);
				{
				State = 72;
				Match(PARAM_TYPE);
				State = 73;
				Match(T__1);
				State = 74;
				Match(NORMAL_STRING);
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TypeContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode T_KEY() { return GetToken(CryptoScriptParser.T_KEY, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode T_VAR() { return GetToken(CryptoScriptParser.T_VAR, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode T_PARAMETER() { return GetToken(CryptoScriptParser.T_PARAMETER, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode T_PATH() { return GetToken(CryptoScriptParser.T_PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode T_TR31H() { return GetToken(CryptoScriptParser.T_TR31H, 0); }
		public TypeContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_type; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.EnterType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.ExitType(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICryptoScriptVisitor<TResult> typedVisitor = visitor as ICryptoScriptVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitType(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public TypeContext type() {
		TypeContext _localctx = new TypeContext(Context, State);
		EnterRule(_localctx, 8, RULE_type);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 77;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 31744L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tr31HeaderContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public Tr31FieldContext[] tr31Field() {
			return GetRuleContexts<Tr31FieldContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public Tr31FieldContext tr31Field(int i) {
			return GetRuleContext<Tr31FieldContext>(i);
		}
		public Tr31HeaderContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tr31Header; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.EnterTr31Header(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.ExitTr31Header(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICryptoScriptVisitor<TResult> typedVisitor = visitor as ICryptoScriptVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTr31Header(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tr31HeaderContext tr31Header() {
		Tr31HeaderContext _localctx = new Tr31HeaderContext(Context, State);
		EnterRule(_localctx, 10, RULE_tr31Header);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 79;
			Match(T__2);
			State = 81;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			do {
				{
				{
				State = 80;
				tr31Field();
				}
				}
				State = 83;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			} while ( _la==TR31_FIELD_NAME );
			State = 85;
			Match(T__3);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class Tr31FieldContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TR31_FIELD_NAME() { return GetToken(CryptoScriptParser.TR31_FIELD_NAME, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TR31_FIELD_VALUE() { return GetToken(CryptoScriptParser.TR31_FIELD_VALUE, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT() { return GetToken(CryptoScriptParser.INT, 0); }
		public Tr31FieldContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tr31Field; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.EnterTr31Field(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.ExitTr31Field(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICryptoScriptVisitor<TResult> typedVisitor = visitor as ICryptoScriptVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitTr31Field(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public Tr31FieldContext tr31Field() {
		Tr31FieldContext _localctx = new Tr31FieldContext(Context, State);
		EnterRule(_localctx, 12, RULE_tr31Field);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 87;
			Match(TR31_FIELD_NAME);
			State = 88;
			Match(T__1);
			State = 89;
			_la = TokenStream.LA(1);
			if ( !(_la==INT || _la==TR31_FIELD_VALUE) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			State = 90;
			Match(T__4);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ExpressionContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode HEX_STRING() { return GetToken(CryptoScriptParser.HEX_STRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode BASE64_STRING() { return GetToken(CryptoScriptParser.BASE64_STRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode NORMAL_STRING() { return GetToken(CryptoScriptParser.NORMAL_STRING, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INT() { return GetToken(CryptoScriptParser.INT, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode PATH() { return GetToken(CryptoScriptParser.PATH, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode TR31_STRING() { return GetToken(CryptoScriptParser.TR31_STRING, 0); }
		public ExpressionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_expression; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.EnterExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.ExitExpression(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICryptoScriptVisitor<TResult> typedVisitor = visitor as ICryptoScriptVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitExpression(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ExpressionContext expression() {
		ExpressionContext _localctx = new ExpressionContext(Context, State);
		EnterRule(_localctx, 14, RULE_expression);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 92;
			_la = TokenStream.LA(1);
			if ( !((((_la) & ~0x3f) == 0 && ((1L << _la) & 7897600L) != 0)) ) {
			ErrorHandler.RecoverInline(this);
			}
			else {
				ErrorHandler.ReportMatch(this);
			    Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class FunctionCallContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode FN() { return GetToken(CryptoScriptParser.FN, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentsContext arguments() {
			return GetRuleContext<ArgumentsContext>(0);
		}
		public FunctionCallContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_functionCall; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.EnterFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.ExitFunctionCall(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICryptoScriptVisitor<TResult> typedVisitor = visitor as ICryptoScriptVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitFunctionCall(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public FunctionCallContext functionCall() {
		FunctionCallContext _localctx = new FunctionCallContext(Context, State);
		EnterRule(_localctx, 16, RULE_functionCall);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 94;
			Match(FN);
			State = 95;
			Match(T__5);
			State = 97;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			if ((((_la) & ~0x3f) == 0 && ((1L << _la) & 140737505100288L) != 0)) {
				{
				State = 96;
				arguments();
				}
			}

			State = 99;
			Match(T__6);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentsContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentContext[] argument() {
			return GetRuleContexts<ArgumentContext>();
		}
		[System.Diagnostics.DebuggerNonUserCode] public ArgumentContext argument(int i) {
			return GetRuleContext<ArgumentContext>(i);
		}
		public ArgumentsContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_arguments; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.EnterArguments(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.ExitArguments(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICryptoScriptVisitor<TResult> typedVisitor = visitor as ICryptoScriptVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArguments(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentsContext arguments() {
		ArgumentsContext _localctx = new ArgumentsContext(Context, State);
		EnterRule(_localctx, 18, RULE_arguments);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 101;
			argument();
			State = 106;
			ErrorHandler.Sync(this);
			_la = TokenStream.LA(1);
			while (_la==T__7) {
				{
				{
				State = 102;
				Match(T__7);
				State = 103;
				argument();
				}
				}
				State = 108;
				ErrorHandler.Sync(this);
				_la = TokenStream.LA(1);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class ArgumentContext : ParserRuleContext {
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode MECHANISM() { return GetToken(CryptoScriptParser.MECHANISM, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public DeclareparamContext declareparam() {
			return GetRuleContext<DeclareparamContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode ID() { return GetToken(CryptoScriptParser.ID, 0); }
		[System.Diagnostics.DebuggerNonUserCode] public FunctionCallContext functionCall() {
			return GetRuleContext<FunctionCallContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ExpressionContext expression() {
			return GetRuleContext<ExpressionContext>(0);
		}
		[System.Diagnostics.DebuggerNonUserCode] public ITerminalNode INFO() { return GetToken(CryptoScriptParser.INFO, 0); }
		public ArgumentContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_argument; } }
		[System.Diagnostics.DebuggerNonUserCode]
		public override void EnterRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.EnterArgument(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override void ExitRule(IParseTreeListener listener) {
			ICryptoScriptListener typedListener = listener as ICryptoScriptListener;
			if (typedListener != null) typedListener.ExitArgument(this);
		}
		[System.Diagnostics.DebuggerNonUserCode]
		public override TResult Accept<TResult>(IParseTreeVisitor<TResult> visitor) {
			ICryptoScriptVisitor<TResult> typedVisitor = visitor as ICryptoScriptVisitor<TResult>;
			if (typedVisitor != null) return typedVisitor.VisitArgument(this);
			else return visitor.VisitChildren(this);
		}
	}

	[RuleVersion(0)]
	public ArgumentContext argument() {
		ArgumentContext _localctx = new ArgumentContext(Context, State);
		EnterRule(_localctx, 20, RULE_argument);
		try {
			State = 115;
			ErrorHandler.Sync(this);
			switch (TokenStream.LA(1)) {
			case MECHANISM:
				EnterOuterAlt(_localctx, 1);
				{
				State = 109;
				Match(MECHANISM);
				}
				break;
			case PARAM_TYPE:
				EnterOuterAlt(_localctx, 2);
				{
				State = 110;
				declareparam();
				}
				break;
			case ID:
				EnterOuterAlt(_localctx, 3);
				{
				State = 111;
				Match(ID);
				}
				break;
			case FN:
				EnterOuterAlt(_localctx, 4);
				{
				State = 112;
				functionCall();
				}
				break;
			case INT:
			case PATH:
			case HEX_STRING:
			case BASE64_STRING:
			case NORMAL_STRING:
			case TR31_STRING:
				EnterOuterAlt(_localctx, 5);
				{
				State = 113;
				expression();
				}
				break;
			case INFO:
				EnterOuterAlt(_localctx, 6);
				{
				State = 114;
				Match(INFO);
				}
				break;
			default:
				throw new NoViableAltException(this);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			ErrorHandler.ReportError(this, re);
			ErrorHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	private static int[] _serializedATN = {
		4,1,136,118,2,0,7,0,2,1,7,1,2,2,7,2,2,3,7,3,2,4,7,4,2,5,7,5,2,6,7,6,2,
		7,7,7,2,8,7,8,2,9,7,9,2,10,7,10,1,0,5,0,24,8,0,10,0,12,0,27,9,0,1,0,1,
		0,1,1,1,1,3,1,33,8,1,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,2,1,
		2,1,2,5,2,49,8,2,10,2,12,2,52,9,2,1,2,1,2,1,2,1,2,1,2,3,2,59,8,2,1,3,1,
		3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,1,3,3,3,76,8,3,1,4,1,
		4,1,5,1,5,4,5,82,8,5,11,5,12,5,83,1,5,1,5,1,6,1,6,1,6,1,6,1,6,1,7,1,7,
		1,8,1,8,1,8,3,8,98,8,8,1,8,1,8,1,9,1,9,1,9,5,9,105,8,9,10,9,12,9,108,9,
		9,1,10,1,10,1,10,1,10,1,10,1,10,3,10,116,8,10,1,10,0,0,11,0,2,4,6,8,10,
		12,14,16,18,20,0,3,1,0,10,14,2,0,9,9,59,59,3,0,9,9,15,15,19,22,124,0,25,
		1,0,0,0,2,32,1,0,0,0,4,58,1,0,0,0,6,75,1,0,0,0,8,77,1,0,0,0,10,79,1,0,
		0,0,12,87,1,0,0,0,14,92,1,0,0,0,16,94,1,0,0,0,18,101,1,0,0,0,20,115,1,
		0,0,0,22,24,3,2,1,0,23,22,1,0,0,0,24,27,1,0,0,0,25,23,1,0,0,0,25,26,1,
		0,0,0,26,28,1,0,0,0,27,25,1,0,0,0,28,29,5,0,0,1,29,1,1,0,0,0,30,33,3,4,
		2,0,31,33,3,16,8,0,32,30,1,0,0,0,32,31,1,0,0,0,33,3,1,0,0,0,34,35,3,8,
		4,0,35,36,5,18,0,0,36,37,5,1,0,0,37,38,3,14,7,0,38,59,1,0,0,0,39,40,3,
		8,4,0,40,41,5,18,0,0,41,42,5,1,0,0,42,43,3,16,8,0,43,59,1,0,0,0,44,45,
		3,8,4,0,45,46,5,18,0,0,46,50,5,1,0,0,47,49,3,6,3,0,48,47,1,0,0,0,49,52,
		1,0,0,0,50,48,1,0,0,0,50,51,1,0,0,0,51,59,1,0,0,0,52,50,1,0,0,0,53,54,
		3,8,4,0,54,55,5,18,0,0,55,56,5,1,0,0,56,57,3,10,5,0,57,59,1,0,0,0,58,34,
		1,0,0,0,58,39,1,0,0,0,58,44,1,0,0,0,58,53,1,0,0,0,59,5,1,0,0,0,60,61,5,
		47,0,0,61,62,5,2,0,0,62,76,5,23,0,0,63,64,5,47,0,0,64,65,5,2,0,0,65,76,
		5,41,0,0,66,67,5,47,0,0,67,68,5,2,0,0,68,76,5,19,0,0,69,70,5,47,0,0,70,
		71,5,2,0,0,71,76,5,18,0,0,72,73,5,47,0,0,73,74,5,2,0,0,74,76,5,21,0,0,
		75,60,1,0,0,0,75,63,1,0,0,0,75,66,1,0,0,0,75,69,1,0,0,0,75,72,1,0,0,0,
		76,7,1,0,0,0,77,78,7,0,0,0,78,9,1,0,0,0,79,81,5,3,0,0,80,82,3,12,6,0,81,
		80,1,0,0,0,82,83,1,0,0,0,83,81,1,0,0,0,83,84,1,0,0,0,84,85,1,0,0,0,85,
		86,5,4,0,0,86,11,1,0,0,0,87,88,5,58,0,0,88,89,5,2,0,0,89,90,7,1,0,0,90,
		91,5,5,0,0,91,13,1,0,0,0,92,93,7,2,0,0,93,15,1,0,0,0,94,95,5,16,0,0,95,
		97,5,6,0,0,96,98,3,18,9,0,97,96,1,0,0,0,97,98,1,0,0,0,98,99,1,0,0,0,99,
		100,5,7,0,0,100,17,1,0,0,0,101,106,3,20,10,0,102,103,5,8,0,0,103,105,3,
		20,10,0,104,102,1,0,0,0,105,108,1,0,0,0,106,104,1,0,0,0,106,107,1,0,0,
		0,107,19,1,0,0,0,108,106,1,0,0,0,109,116,5,23,0,0,110,116,3,6,3,0,111,
		116,5,18,0,0,112,116,3,16,8,0,113,116,3,14,7,0,114,116,5,17,0,0,115,109,
		1,0,0,0,115,110,1,0,0,0,115,111,1,0,0,0,115,112,1,0,0,0,115,113,1,0,0,
		0,115,114,1,0,0,0,116,21,1,0,0,0,9,25,32,50,58,75,83,97,106,115
	};

	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN);


}
